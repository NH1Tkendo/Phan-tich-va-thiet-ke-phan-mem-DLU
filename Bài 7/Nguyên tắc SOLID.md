![[SOLID-Principles.png|500]]

| Chữ cái | Nguyên tắc (tiếng Anh)                | Nguyên tắc (tiếng Việt)         | Nội dung tóm tắt                                                                                                                                 |
| ------- | ------------------------------------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| S       | Single Responsibility Principle (SRP) | Nguyên tắc Trách nhiệm duy nhất | Một lớp (class) hoặc mô-đun (module) chỉ nên có một lý do duy nhất để thay đổi. (Tức là chỉ chịu trách nhiệm cho một công việc cụ thể)           |
| O       | Open/Closed Principle (OCP)           | Nguyên tắc Mở/Đóng              | Một thực thể (class, module, function) nên mở để mở rộng, nhưng đóng để sửa đổi. (Thêm chức năng mới mà không cần thay đổi mã nguồn hiện có)     |
| L       | Liskov Substitution Principle (LSP)   | Nguyên tắc Thay thế Liskov      | Các đối tượng của lớp con có thể thay thế cho các đối tượng của lớp cha mà không làm thay đổi tính đúng đắn của chương trình                     |
| I       | Interface Segregation Principle (ISP) | Nguyên tắc Phân tách giao diện  | Thay vì sử dụng một giao diện (interface) lớn, cồng kềnh, nên tách nó thành nhiều giao diện nhỏ hơn, cụ thể hơn                                  |
| D       | Dependency Inversion Principle (DIP)  | Nguyên tắc Đảo ngược phụ thuộc  | Các module cấp cao không nên phụ thuộc vào các module cấp thấp. Cả hai nên phụ thuộc vào Abstraction (trừu tượng hóa - Interface/Abstract Class) |

## Ví dụ
| Nguyên tắc (tiếng Việt)         | Ví dụ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Nguyên tắc Trách nhiệm duy nhất | - Không nên: Có một lớp OrderProcessor vừa xử lý logic đặt hàng, vừa gửi email xác nhận, và vừa cập nhật tồn kho. Nếu logic gửi email thay đổi, lớp này cũng phải thay đổi, vi phạm SRP<br><br>- Nên áp dụng: Chia thành các dịch vụ/lớp riêng biệt:<br><br>  + OrderService (Dịch vụ Đặt hàng): Chỉ xử lý logic tạo, lưu trữ và theo dõi trạng thái đơn hàng (FR-3.5)<br><br>  + InventoryService (Dịch vụ Tồn kho): Chỉ xử lý logic kiểm tra và trừ/cộng số lượng tồn kho (Yêu cầu nghiệp vụ)<br><br>  + NotificationService (Dịch vụ Thông báo): Chỉ chịu trách nhiệm gửi email xác nhận hoặc các thông báo khác (FR-3.5)                                                                              |
| Nguyên tắc Mở/Đóng              | - Không nên: Sửa đổi lớp PaymentProcessor hiện tại, mỗi khi thêm một phương thức thanh toán mới<br><br>- Nên áp dụng:<br><br>  + Tạo một Interface chung là IPaymentGateway với phương thức processPayment()<br><br>  + Mỗi phương thức thanh toán mới (như CreditCardGateway và EWalletGateway) sẽ kế thừa (mở rộng) Interface này<br><br>  + Lớp OrderService sử dụng Interface IPaymentGateway mà không cần biết triển khai cụ thể. Khi thêm Ví điện tử, ta chỉ cần thêm lớp mới mà không cần sửa đổi OrderService                                                                                                                                                                                     |
| Nguyên tắc Thay thế Liskov      | - Nên áp dụng:<br><br>  + Tạo lớp cha trừu tượng (Abstract Class) Book với các thuộc tính chung (title, author, price - FR-2.3)<br><br>  + Tạo các lớp con như EBook và PaperbackBook<br><br>  + Lớp EBook không được làm những việc mà PaperbackBook làm (ví dụ: tính phí vận chuyển - do ebook không vận chuyển). Nếu hệ thống gọi hàm calculateShippingCost() trên một đối tượng EBook và nó trả về lỗi hoặc một giá trị không hợp lệ, thì đó là vi phạm LSP<br><br>  + Để tuân thủ, nên tách logic đặc thù (như vận chuyển) ra khỏi lớp Book chung, hoặc đảm bảo rằng tất cả các sách đều có thể được xử lý (ví dụ, EBook trả về phí vận chuyển bằng 0)                                               |
| Nguyên tắc Phân tách giao diện  | - Không nên: Tạo một Interface IUserRepository chứa mọi phương thức: createUser(), updateProfile(), getHistory(), manageInventory(), sendEmail()<br><br>- Nên áp dụng: Phân tách Interface theo trách nhiệm:<br><br>  + ICustomerProfileManager: Chỉ có updateProfile(), getHistory() (FR-1.4, FR-1.5)<br><br>  + IAdminInventoryManager: Chỉ có manageInventory()<br><br>  + Dịch vụ User & Auth Service (quản lý thông tin người dùng) chỉ cần triển khai ICustomerProfileManager, trong khi dịch vụ quản lý backend cần triển khai IAdminInventoryManager                                                                                                                                              |
| Nguyên tắc Đảo ngược phụ thuộc  | - Không nên: Lớp OrderService tạo trực tiếp một đối tượng cụ thể là PostgreSQLDatabase để lưu đơn hàng. (Sự phụ thuộc trực tiếp vào chi tiết cấp thấp).<br><br>- Nên áp dụng:<br><br>  + Tạo một Interface (Abstraction) là IOrderRepository<br><br>  + Lớp cấp thấp PostgreSQLOrderRepository sẽ triển khai IOrderRepository<br><br>  + OrderService (module cấp cao) sẽ nhận IOrderRepository thông qua Dependency Injection (DI) trong constructor<br><br>  + Điều này giúp OrderService không quan tâm đến loại cơ sở dữ liệu đang dùng, có thể dễ dàng chuyển sang dùng MongoDbOrderRepository mà không cần thay đổi mã nguồn của OrderService, đảm bảo tính linh hoạt và khả năng mở rộng (NFR-5.2) |